"""Simulate ESC1 by requesting a certificate from a template open to all users."""

from __future__ import annotations

import json
import logging
from pathlib import Path

from adcs_lab.detection.adcs_enum import CertificateTemplate, load_mock_environment

LOGGER = logging.getLogger(__name__)


class ESC1Exploit:
    """Model the ESC1 enrollment hijack attack path using mock inputs."""

    def __init__(self, template: CertificateTemplate):
        self.template = template

    def craft_csr(self, username: str) -> dict[str, str]:
        """Construct a simplified certificate signing request payload."""
        return {
            "subject": f"CN={username}, OU=Engineering, O=Corp",
            "san": "user@corp.local",
            "eku": self.template.enhanced_key_usages,
        }

    def execute(self, username: str) -> dict[str, str]:
        """Simulate requesting and receiving a certificate using the vulnerable template."""
        if not self.template.is_esc1():
            raise ValueError("Template is not vulnerable to ESC1")
        csr = self.craft_csr(username)
        LOGGER.info("Simulating ESC1 issuance for %s via %s", username, self.template.name)
        return {
            "template": self.template.name,
            "csr": csr,
            "issued_certificate": f"mock-cert-{username}.pem",
            "pfx_password": "P@ssw0rd!",
            "notes": "Use pkinittools/rubeus with the PFX to request a TGT",
        }


def main() -> None:
    """Run the ESC1 exploit demonstration standalone."""
    env = load_mock_environment()
    template = env.templates[0]
    exploit = ESC1Exploit(template)
    result = exploit.execute("attacker")
    Path("esc1_result.json").write_text(json.dumps(result, indent=2))
    print("[+] ESC1 exploitation simulated. Output -> esc1_result.json")


if __name__ == "__main__":
    main()
